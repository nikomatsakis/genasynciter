use std::ops::ControlFlow;
use std::pin::Pin;

use super::iterator::{IntoIterator, Iterator};
use super::stream::Stream;

pub trait Generator: Stream {
    fn next(self: Pin<&mut Self>) -> Option<Self::Item>;
}

impl<G> IntoIterator for G
where
    G: Generator + Unpin,
{
    type Item = G::Item;

    fn into_iter(self) -> impl Iterator<Item = Self::Item> {
        struct I<G> {
            this: G,
        }

        impl<G> Iterator for I<G>
        where
            G: Generator + Unpin,
        {
            type Item = G::Item;

            fn next(&mut self) -> Option<Self::Item> {
                Pin::new(&mut self.this).next()
            }
        }

        I { this: self }
    }
}

/// An example generator: imagine this as code generated by the compiler
pub fn gen_range(from: usize, to: usize) -> impl Generator<Item = usize> {
    struct TheGen {
        counter: usize,
        to: usize,
    }

    impl Generator for TheGen {
        fn next(self: Pin<&mut Self>) -> Option<Self::Item> {
            let this = self.get_mut();
            if this.counter >= this.to {
                None
            } else {
                this.counter += 1;
                Some(this.counter - 1)
            }
        }
    }

    impl Stream for TheGen {
        type Item = usize;

        fn exec(self, mut op: impl FnMut(Self::Item) -> std::ops::ControlFlow<()>) {
            for i in self.counter..self.to {
                match op(i) {
                    ControlFlow::Break(()) => return,
                    ControlFlow::Continue(()) => (),
                }
            }
        }
    }

    TheGen { counter: from, to }
}
